<!DOCTYPE html>
<html>
<head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel='stylesheet' href='slides.css'/>
</head>
<body>
    <textarea id="source">

class: center, middle, inverse

# Non-Relational Databases
Adam Brenecki, Adrian Colbert  
adambrenecki.github.io/non-relational-databases

---
## What is a non-relational database?

- Any database that doesn't store data in tabular relations
- Also referred to as **NoSQL**
- ...sometimes

## What are we covering today?

- Key-value databases
- Document-oriented databases
- Graph databases
- BigTable

???

Adrian thinks NoSQL is a stupid term and sounds like a Microsoft product.

---
class: center, middle, inverse

## Key-Value Stores

---

## What is a key-value store?

- Stores key-value pairs
- Similar to a hash map
- 

---

## Content-Addressable Data Stores

Some key-value stores accept just a value, and generate a key by passing the value through some sort of hash algorithm.

- Git object store
    - Values follow predefined binary structure
    - Keys are simply the SHA-1 hashes of the values
- Camlistore
    - Arbitrary binary values
        - Some features of Camlistore store JSON in values
    - Keys consist of a hash digest combined with the name of the hashing algorithm

.footnote.citation[(Chacon 2009, Fitzpatrick 2014)]

???

---

## Modelling Other Structures On Top Of Key-Value Stores

Content-addressable stores are often used in such a manner; the generated key is stored and referenced 

- 

???

Of course, this has the disadvantage that the key-value store isn't easily understandable unless you happen to know the particular structure in use. If you had a generic UI for editing the contents of a key-value store, something equivalent to PhpMyAdmin or similar, it'd be quite difficult to update.

---
class: center, middle, inverse

## Document-Oriented Databases

Focusing on Apache CouchDB

???

Now, we move on to document-oriented databases. There's a whole range of them out there, and unlike relational DBMSes they work very differently, so we're going to focus on CouchDB, a document-oriented DBMS made by the Apache Foundation.

---

## What is a document?

- Each document is a map of key-value pairs
- Generally represented in JSON, or a similar format like YAML or BSON
- Sometimes represented in XML

### JSON

A text-based serialisation format based on JavaScript objects.

- Object (key-value map, string keys, heterogenous values)
- List (ordered list)
- Number
- String (Unicode)
- Boolean
- Null

```json
{
    'title': 'Hello World',
    'body': 'This is my first blog post...',
}
```

.footnote.citation[(Ecma International 2013)]

???

Most document-oriented DBMSes consider a 'document' to be some sort of semistructured data structure; CouchDB uses JSON, MongoDB uses a JSON-based binary format called BSON; there are others that use XML.

JSON is based on JavaScript objects, which are basically key-value maps; here the key-value pairs in a document describe different attributes of the same entity, unlike in the key-value stores in the previous section where each key-value pair is a different entity.

You'll notice in that list of data types that we can store multi-valued attributes inside a document, which we can't do in a relational database; the implications of that are discussed a few slides along.

---

## What is a document-oriented database?

A **collection** of documents.

- In some document DBMSes, collections are like relations; all members are of a similar type.
- In others (like CouchDB), collections are like databases; they contain all of the documents related to a particular application in one big heap.

???

So, document-oriented DBMSes store collections of these documents. Some DBMSes allow you to have multiple collections 

---

## Why use a document-oriented database?

**Example:** Database for an invoicing system.

### Relational Database

#### Invoices

| Ref | Customer | Date |
|-
| DOEJ001 | Jane Doe | 2014-02-03 |
| SMIJ002 | John Smith | 2014-02-04 |

#### InvoiceItems

| InvoiceRef | ItemNum | Description | Amount | Price |
|-
| DOEJ001 | 1 | Widget | 2 | 20.55 |
| DOEJ001 | 2 | Wodget | 1 | 8 |


---

## Why use a document-oriented database?

### Document-Oriented Database

```json
{
    'type': 'invoice',
    'id': 'DOEJ001',
    'customer': 'Jane Doe',
    'items': [
        {
            'description': 'Widget',
            'amount': 2,
            'price': 20.55,
        },
        {
            'description': 'Wodget',
            'amount': 1,
            'price': 8,
        },
    ],
}
```

.footnote.citation[(Anderson 2010 ch. 1)]

???

Earlier, when talking about key-value stores, I mentioned that key-value stores that store data structures as values aren't human readable without the help of software that understands the specific data structure in use.

This is sort of the opposite; the document makes complete sense to a human in its native form, even more so than a relational database would. In the 

---

## Why use a document-oriented database?

Some things to note:

- Not an unconstrained free-for-all
- Still possible to have relationships between objects like in a relational database - but this causes problems when querying

.footnote.citation[(Anderson 2010)]

???

So, you might be thinking that a document-oriented database is just a free-for-all - you can just add whatever attributes and values you like, and the database quickly becomes a completely unstructured mess.

Because of this, CouchDB allows you to specify *validation functions*, which are run on every document whenever it's added or updated.

---

## Querying a Document-Oriented DB with Map-Reduce

- Written in a regular programming language
- Map-reduce views specify two functions:
- Map: convert each document to a key-value pair
- Reduce: combine key-value pairs
- Not very efficient on their own, but *very* cacheable
- Only need to update the results of 

---

## The Map Function

The map function is run once on every document in the database.

**Input:** One document.  

### An Example Map Function

```
map(object):
if the object is a church:
emit(object.parish, 1)
else
return null
```

---

## The Reduce Function

---

## Examples of Map-Reduce

- Selection (`WHERE` in SQL): Map function only emits some documents 
- Projection (`SELECT ... FROM` in SQL): Map function only emits some attributes of a document
- Ordering (`ORDER BY` in SQL): Map function the attribute(s) to order by as the key
- Aggregation (`GROUP BY` in SQL): Aggregate in the reduce function
- Joining (`JOIN` in SQL): This is more difficult...

---

## Making Map-Reduce Efficient

---

## Limitations

Map functions and reduce functions must be idempotent, as their output is cached. This causes problems. For example:

> For each church, display the name of the church, the name of the parish, and the parish priest.

### SQL

```sql
SELECT c.name, p.name, p.priest
FROM churches c JOIN parishes p ON (...)
```

### CouchDB map-reduce

- One CouchDB view returns church names and parish UUIDs
- Another view returns parish UUIDs, parish names, and parish priests
- The calling application has to then match them up

---

## Map-Reduce-Merge

- Proposed by researchers from Yahoo and UCLA
- Adds a third step, "merge", after map and reduce

.footnote.citation[(Yang et. al., 2007)]

---

## Ordinary Queries on a Document-Oriented Database

While CouchDB can only be queried using map-reduce, MongoDB collections can be queried in a manner reminiscent of SQL.

```javascript
mongo.churches.find({name: 'Christ Church'})
mongo.blogPosts.find({'address.suburb': {$in: ['Adelaide', 'North Adelaide']}})
```

Sadly, Mongo doesn't support anything analogous to SQL `JOIN`s.

.footnote.citation[(Kleinman 2014, Kleinman 2013)]

???

It's worth pointing out that map-reduce is not the only way you can query a document-oriented database. MongoDB does support map-reduce, but you can also query a collection by expressing your query as a JavaScript object, with a syntax that's very reminiscent of SQL. You can even set indexes on attributes, as you can in relational DBMSes.

Unfortunately, Mongo also doesn't support JOINs.

---

class: center, middle, inverse

## Graph Databases

Focusing on the GOOD model

---

![Evolution of databases](images/evolution_of_databases.png)

.footnote.citation[(Angles & Gutierrez, 2008, Fig. 1)]

???

- Evolution of database types

---

## What is a graph database?

- Nodes with relationships

- Comparable to a multidimensional linked list

- Updates, additions and deletions are performed just like a linked list

- Queries performed recursively, often through macros

- Far more variations than just the example of GOOD

.footnote.citation[(Gyssens et. al., 1994)]

???

- Functions like a multidimensional linked list
- Depending on implementation, can be constructed and queried with a common programming language, like C++
- Can be traversed or queried with recursive methods
- Updates, additions and deletions are performed just like a linked list
- Queries tend to involve performing transforming actions on the database which results in another database graph, usually temporary.

---

![An example of a simple GOOD database](images/good_example.png)

.footnote.citation[(Gyssens et. al., 1994, Fig. 2)]

???

- As you can clearly see, there are a series of repeated node patterns joined together.
- The basic node patterns constitute the schema, which are then joined with associations to form the database.
- For example, if wanted to delete all Classical Music, delete the Info node with String 'Classical Music'

---

## Why use a graph database?

- Connections between data are as important as data itself, or more so
- Obvious example is social networking due to many-to-many associations
- Performance considerations versus relational databases for certain data sets
- 

.footnote.citation[(Angles & Gutierrez, 2008) (Holzschuher & Peinl, 2013)]

---
## Performance of Relational versus Graph

- Testing of Cypher and JPA MySQL queries on the same data

- 200MB of dummy friendship data of the form:

| Person | Activity |
|-
| first and last name | title |
| birthday, age | body |
| gender | verb |
| interests (2-5) | time stamp |
| messages (2-5) | actor |
| affiliations with organisations (0-3) | object |
| addresses (1-2) | target |
| group memberships (0-5) | generator |
| activities (1-25) | |


.footnote.citation[(Holzschuher & Peinl, 2013, Table 1: Data for people and activities)]

???

- Cypher being a graph query language
- Java Persistence API MySQL is a Java variant of MySQL
- Data converted from graph/object to relational with Hibernate Object Relational Mapping, which is a Java library
- REST is an architectural style. Was used in the design of HTTP1.1
- 

---

## Performance of Relational versus Graph

| Organisation | Message | Address |
|-
| name | title | street name |
| sector | text | house number |
| website | time stamp | city name |
| address | 1-3 recipients | zip code |
| | | state |
| | | country |
| | | longitude, latitude |

- Total of 10,003 'people' and 137,000 'friendships'

- Average of 28 friendships per person


.footnote.citation[(Holzschuher & Peinl, 2013, Table 2: Data for organisations, messages and addresses)]

---

## Performance of Relational versus Graph

Example of Cypher query used:

```
START person=node:people(id = {id})
MATCH person-[:FRIEND_OF]->friend-[:FRIEND_OF]->friend_of_friend
WHERE no (friend_of_friend<-[:FRIEND_OF]-person)
RETURN friend_of_friend, COUNT(*)
ORDER BY COUNT(*) DESC
```
Example of SQL query used:

```
SELECT persondb0.ID, persondb0.display_name
FROM person persondb0
WHERE persondb0.oid IN (
SELECT frienddb2.friend_id
FROM person persondb1, friend frienddb2
WHERE persondb1.oid=frienddb2.person_id
AND (persondb1.person_id IN(?)))
```

.footnote.citation[(Holzschuher & Peinl, 2013)]

---

## Performance of Relational versus Graph

Results, edited for clarity

| Person benchmark | Cypher REST | Cypher | JPA MySQL |
|-
| 2,000 people | 4,600ms | 180ms | 30,010ms |
| 200 * 10 people | 2,038ms | 173ms | 6,474ms |
| 2,000 people's friends | 7,347ms | 931ms | 3,558,882ms|
| 200 * 10 people's friends | 4,381ms | 850ms | 384,025ms |

.footnote.citation[(Holzschuher & Peinl, 2013, Table 3: Person benchmark for 10,000 people, average time needed, average over 10 runs)]

???

- Cypher REST is where the queries were run over a network to the database running on a server. The JPA MySQL implementation ran into errors and was also super slow, so they discarded it and investigated other graph query languages.

---

# Bibliography

TODO: EXPORT BIBLIOGRAPHY FROM ZOTERO

???

This is our bibliography.

If you'd like to know more about document-oriented databases, *CouchDB: The Definitive Guide* by Chris Anderson is an excellent resource; it includes examples of building a real-world blog engine using nothing but CouchDB. Camlistore is also a really interesting project that's worth checking out.

---
class: center, middle, inverse

# Thank You

Adam Brenecki, Adrian Colbert

adambrenecki.github.io/non-relational-databases

[download slides](https://github.com/adambrenecki/non-relational-databases/archive/master.zip)

    </textarea>
    <script src="http://gnab.github.io/remark/downloads/remark-0.6.3.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        var slideshow = remark.create();
    </script>
</body>
</html>
